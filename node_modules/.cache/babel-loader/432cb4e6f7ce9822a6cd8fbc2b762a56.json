{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.MobileDragDrop = global.MobileDragDrop || {});\n})(this, function (exports) {\n  'use strict';\n\n  function isTopLevelEl(el) {\n    return el === document.body || el === document.documentElement;\n  }\n\n  function getElementViewportOffset(el, axis) {\n    var offset;\n\n    if (isTopLevelEl(el)) {\n      offset = axis === 0 ? el.clientLeft : el.clientTop;\n    } else {\n      var bounds = el.getBoundingClientRect();\n      offset = axis === 0 ? bounds.left : bounds.top;\n    }\n\n    return offset;\n  }\n\n  function getElementViewportSize(el, axis) {\n    var size;\n\n    if (isTopLevelEl(el)) {\n      size = axis === 0 ? window.innerWidth : window.innerHeight;\n    } else {\n      size = axis === 0 ? el.clientWidth : el.clientHeight;\n    }\n\n    return size;\n  }\n\n  function getSetElementScroll(el, axis, scroll) {\n    var prop = axis === 0 ? \"scrollLeft\" : \"scrollTop\";\n    var isTopLevel = isTopLevelEl(el);\n\n    if (arguments.length === 2) {\n      if (isTopLevel) {\n        return document.body[prop] || document.documentElement[prop];\n      }\n\n      return el[prop];\n    }\n\n    if (isTopLevel) {\n      document.documentElement[prop] += scroll;\n      document.body[prop] += scroll;\n    } else {\n      el[prop] += scroll;\n    }\n  }\n\n  function isScrollable(el) {\n    var cs = getComputedStyle(el);\n\n    if (el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\")) {\n      return true;\n    }\n\n    if (el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\")) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function findScrollableParent(el) {\n    do {\n      if (!el) {\n        return undefined;\n      }\n\n      if (isScrollable(el)) {\n        return el;\n      }\n\n      if (el === document.documentElement) {\n        return null;\n      }\n    } while (el = el.parentNode);\n\n    return null;\n  }\n\n  function determineScrollIntention(currentCoordinate, size, threshold) {\n    if (currentCoordinate < threshold) {\n      return -1;\n    } else if (size - currentCoordinate < threshold) {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  function determineDynamicVelocity(scrollIntention, currentCoordinate, size, threshold) {\n    if (scrollIntention === -1) {\n      return Math.abs(currentCoordinate - threshold);\n    } else if (scrollIntention === 1) {\n      return Math.abs(size - currentCoordinate - threshold);\n    }\n\n    return 0;\n  }\n\n  function isScrollEndReached(axis, scrollIntention, scrollBounds) {\n    var currentScrollOffset = axis === 0 ? scrollBounds.scrollX : scrollBounds.scrollY;\n\n    if (scrollIntention === 1) {\n      var maxScrollOffset = axis === 0 ? scrollBounds.scrollWidth - scrollBounds.width : scrollBounds.scrollHeight - scrollBounds.height;\n      return currentScrollOffset >= maxScrollOffset;\n    } else if (scrollIntention === -1) {\n      return currentScrollOffset <= 0;\n    }\n\n    return true;\n  }\n\n  var _options = {\n    threshold: 75,\n    velocityFn: function (velocity, threshold) {\n      var multiplier = velocity / threshold;\n      var easeInCubic = multiplier * multiplier * multiplier;\n      return easeInCubic * threshold;\n    }\n  };\n  var _scrollIntentions = {\n    horizontal: 0,\n    vertical: 0\n  };\n  var _dynamicVelocity = {\n    x: 0,\n    y: 0\n  };\n\n  var _scrollAnimationFrameId;\n\n  var _currentCoordinates;\n\n  var _hoveredElement;\n\n  var _scrollableParent;\n\n  var _translateDragImageFn;\n\n  function handleDragImageTranslateOverride(event, currentCoordinates, hoveredElement, translateDragImageFn) {\n    _currentCoordinates = currentCoordinates;\n    _translateDragImageFn = translateDragImageFn;\n\n    if (_hoveredElement !== hoveredElement) {\n      _hoveredElement = hoveredElement;\n      _scrollableParent = findScrollableParent(_hoveredElement);\n    }\n\n    var performScrollAnimation = updateScrollIntentions(_currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity);\n\n    if (performScrollAnimation) {\n      scheduleScrollAnimation();\n    } else if (!!_scrollAnimationFrameId) {\n      window.cancelAnimationFrame(_scrollAnimationFrameId);\n      _scrollAnimationFrameId = null;\n    }\n  }\n\n  function scheduleScrollAnimation() {\n    if (!!_scrollAnimationFrameId) {\n      return;\n    }\n\n    _scrollAnimationFrameId = window.requestAnimationFrame(scrollAnimation);\n  }\n\n  function scrollAnimation() {\n    var scrollDiffX = 0,\n        scrollDiffY = 0,\n        isTopLevel = isTopLevelEl(_scrollableParent);\n\n    if (_scrollIntentions.horizontal !== 0) {\n      scrollDiffX = Math.round(_options.velocityFn(_dynamicVelocity.x, _options.threshold) * _scrollIntentions.horizontal);\n      getSetElementScroll(_scrollableParent, 0, scrollDiffX);\n    }\n\n    if (_scrollIntentions.vertical !== 0) {\n      scrollDiffY = Math.round(_options.velocityFn(_dynamicVelocity.y, _options.threshold) * _scrollIntentions.vertical);\n      getSetElementScroll(_scrollableParent, 1, scrollDiffY);\n    }\n\n    if (isTopLevel) {\n      _translateDragImageFn(scrollDiffX, scrollDiffY);\n    } else {\n      _translateDragImageFn(0, 0);\n    }\n\n    _scrollAnimationFrameId = null;\n\n    if (updateScrollIntentions(_currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity)) {\n      scheduleScrollAnimation();\n    }\n  }\n\n  function updateScrollIntentions(currentCoordinates, scrollableParent, threshold, scrollIntentions, dynamicVelocity) {\n    if (!currentCoordinates || !scrollableParent) {\n      return false;\n    }\n\n    var scrollableParentBounds = {\n      x: getElementViewportOffset(scrollableParent, 0),\n      y: getElementViewportOffset(scrollableParent, 1),\n      width: getElementViewportSize(scrollableParent, 0),\n      height: getElementViewportSize(scrollableParent, 1),\n      scrollX: getSetElementScroll(scrollableParent, 0),\n      scrollY: getSetElementScroll(scrollableParent, 1),\n      scrollWidth: scrollableParent.scrollWidth,\n      scrollHeight: scrollableParent.scrollHeight\n    };\n    var currentCoordinatesOffset = {\n      x: currentCoordinates.x - scrollableParentBounds.x,\n      y: currentCoordinates.y - scrollableParentBounds.y\n    };\n    scrollIntentions.horizontal = determineScrollIntention(currentCoordinatesOffset.x, scrollableParentBounds.width, threshold);\n    scrollIntentions.vertical = determineScrollIntention(currentCoordinatesOffset.y, scrollableParentBounds.height, threshold);\n\n    if (scrollIntentions.horizontal && isScrollEndReached(0, scrollIntentions.horizontal, scrollableParentBounds)) {\n      scrollIntentions.horizontal = 0;\n    } else if (scrollIntentions.horizontal) {\n      dynamicVelocity.x = determineDynamicVelocity(scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold);\n    }\n\n    if (scrollIntentions.vertical && isScrollEndReached(1, scrollIntentions.vertical, scrollableParentBounds)) {\n      scrollIntentions.vertical = 0;\n    } else if (scrollIntentions.vertical) {\n      dynamicVelocity.y = determineDynamicVelocity(scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold);\n    }\n\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\n  }\n\n  var scrollBehaviourDragImageTranslateOverride = handleDragImageTranslateOverride;\n  exports.scrollBehaviourDragImageTranslateOverride = scrollBehaviourDragImageTranslateOverride;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["scroll-behaviour.ts"],"names":[],"mappings":"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","sourcesContent":["//<editor-fold desc=\"static scroll utils\">\n\nimport { DragImageTranslateOverrideFn } from \"./index\";\nimport { Point } from \"./internal/dom-utils\";\n\ninterface ScrollIntentions {\n    horizontal:ScrollIntention;\n    vertical:ScrollIntention;\n}\n\ninterface IScrollBounds {\n    x:number;\n    y:number;\n    width:number;\n    height:number;\n    scrollX:number;\n    scrollY:number;\n    scrollHeight:number;\n    scrollWidth:number;\n}\n\nconst enum ScrollIntention {\n    NONE = 0,\n    LEFT_OR_TOP = -1,\n    RIGHT_OR_BOTTOM = 1\n}\n\nconst enum ScrollAxis {\n    HORIZONTAL,\n    VERTICAL\n}\n\nfunction isTopLevelEl( el:HTMLElement ):boolean {\n\n    return (el === document.body || el === document.documentElement);\n}\n\nfunction getElementViewportOffset( el:HTMLElement, axis:ScrollAxis ) {\n    let offset:number;\n\n    if( isTopLevelEl( el ) ) {\n        offset = (axis === ScrollAxis.HORIZONTAL) ? el.clientLeft : el.clientTop;\n    }\n    else {\n        const bounds = el.getBoundingClientRect();\n        offset = (axis === ScrollAxis.HORIZONTAL) ? bounds.left : bounds.top;\n    }\n\n    return offset;\n}\n\nfunction getElementViewportSize( el:HTMLElement, axis:ScrollAxis ) {\n    let size:number;\n\n    if( isTopLevelEl( el ) ) {\n        size = (axis === ScrollAxis.HORIZONTAL) ? window.innerWidth : window.innerHeight;\n    }\n    else {\n        size = (axis === ScrollAxis.HORIZONTAL) ? el.clientWidth : el.clientHeight;\n    }\n\n    return size;\n}\n\nfunction getSetElementScroll( el:HTMLElement, axis:ScrollAxis, scroll?:number ) {\n    const prop = (axis === ScrollAxis.HORIZONTAL) ? \"scrollLeft\" : \"scrollTop\";\n\n    // abstracting away compatibility issues on scroll properties of document/body\n    const isTopLevel = isTopLevelEl( el );\n\n    if( arguments.length === 2 ) {\n\n        if( isTopLevel ) {\n            return document.body[ prop ] || document.documentElement[ prop ];\n        }\n\n        return el[ prop ];\n    }\n\n    if( isTopLevel ) {\n        document.documentElement[ prop ] += scroll;\n        document.body[ prop ] += scroll;\n    }\n    else {\n        el[ prop ] += scroll;\n    }\n}\n\n//TODO check if scroll end is reached according to scroll intention? this is needed to implement scroll chaining\nfunction isScrollable( el:HTMLElement ):boolean {\n    const cs = getComputedStyle( el );\n\n    if( el.scrollHeight > el.clientHeight && (cs.overflowY === \"scroll\" || cs.overflowY === \"auto\") ) {\n        return true;\n    }\n\n    if( el.scrollWidth > el.clientWidth && (cs.overflowX === \"scroll\" || cs.overflowX === \"auto\") ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction findScrollableParent( el:HTMLElement ):HTMLElement {\n    do {\n        if( !el ) {\n            return undefined;\n        }\n        if( isScrollable( el ) ) {\n            return el;\n        }\n        if( el === document.documentElement ) {\n            return null;\n        }\n    } while( el = <HTMLElement>el.parentNode );\n    return null;\n}\n\nfunction determineScrollIntention( currentCoordinate:number, size:number, threshold:number ):ScrollIntention {\n\n    // LEFT / TOP\n    if( currentCoordinate < threshold ) {\n        return ScrollIntention.LEFT_OR_TOP;\n    }\n    // RIGHT / BOTTOM\n    else if( size - currentCoordinate < threshold ) {\n        return ScrollIntention.RIGHT_OR_BOTTOM;\n    }\n    // NONE\n    return ScrollIntention.NONE;\n}\n\nfunction determineDynamicVelocity( scrollIntention:ScrollIntention, currentCoordinate:number, size:number, threshold:number ):number {\n\n    if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        return Math.abs( currentCoordinate - threshold );\n    }\n    else if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        return Math.abs( size - currentCoordinate - threshold );\n    }\n\n    return 0;\n}\n\nfunction isScrollEndReached( axis:ScrollAxis, scrollIntention:ScrollIntention, scrollBounds:IScrollBounds ) {\n\n    const currentScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollX) : (scrollBounds.scrollY);\n\n    // wants to scroll to the right/bottom\n    if( scrollIntention === ScrollIntention.RIGHT_OR_BOTTOM ) {\n\n        const maxScrollOffset = (axis === ScrollAxis.HORIZONTAL) ? (scrollBounds.scrollWidth - scrollBounds.width) : (scrollBounds.scrollHeight -\n            scrollBounds.height);\n\n        // is already at the right/bottom edge\n        return currentScrollOffset >= maxScrollOffset;\n    }\n    // wants to scroll to the left/top\n    else if( scrollIntention === ScrollIntention.LEFT_OR_TOP ) {\n\n        // is already at left/top edge\n        return (currentScrollOffset <= 0);\n    }\n    // no scroll\n    return true;\n}\n\n//</editor-fold>\n\nlet _options:ScrollOptions = {\n    threshold: 75,\n    // simplified cubic-ease-in function\n    velocityFn: function( velocity:number, threshold:number ) {\n        const multiplier = velocity / threshold;\n        const easeInCubic = multiplier * multiplier * multiplier;\n        return easeInCubic * threshold;\n    }\n};\n\nlet _scrollIntentions:ScrollIntentions = {\n    horizontal: ScrollIntention.NONE,\n    vertical: ScrollIntention.NONE\n};\n\nlet _dynamicVelocity:Point = {\n    x: 0,\n    y: 0\n};\n\nlet _scrollAnimationFrameId:any;\nlet _currentCoordinates:Point;\nlet _hoveredElement:HTMLElement;\nlet _scrollableParent:HTMLElement;\nlet _translateDragImageFn:( offsetX:number, offsetY:number ) => void;\n\n/**\n * core handler function\n */\nfunction handleDragImageTranslateOverride( event:TouchEvent,\n                                           currentCoordinates:Point,\n                                           hoveredElement:HTMLElement,\n                                           translateDragImageFn:( scrollDiffX:number, scrollDiffY:number ) => void ):void {\n\n    _currentCoordinates = currentCoordinates;\n    _translateDragImageFn = translateDragImageFn;\n\n    // update parent if hovered element changed\n    if( _hoveredElement !== hoveredElement ) {\n\n        _hoveredElement = hoveredElement;\n        _scrollableParent = findScrollableParent( _hoveredElement );\n    }\n\n    // update scroll intention and check if we should scroll at all\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    const performScrollAnimation = updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity );\n\n    // no animation in progress but scroll is intended\n    if( performScrollAnimation ) {\n\n        // setup scroll animation frame\n        scheduleScrollAnimation();\n    }\n    else if( !!_scrollAnimationFrameId ) {\n\n        window.cancelAnimationFrame( _scrollAnimationFrameId );\n        _scrollAnimationFrameId = null;\n    }\n}\n\n//<editor-fold desc=\"programmatic scroll animation frame handler\">\n\nfunction scheduleScrollAnimation() {\n\n    // prevent scheduling when already scheduled\n    if( !!_scrollAnimationFrameId ) {\n\n        return;\n    }\n\n    _scrollAnimationFrameId = window.requestAnimationFrame( scrollAnimation );\n}\n\nfunction scrollAnimation() {\n\n    let scrollDiffX = 0,\n        scrollDiffY = 0,\n        isTopLevel = isTopLevelEl( _scrollableParent );\n\n    if( _scrollIntentions.horizontal !== ScrollIntention.NONE ) {\n\n        scrollDiffX = Math.round( _options.velocityFn( _dynamicVelocity.x, _options.threshold ) * _scrollIntentions.horizontal );\n        getSetElementScroll( _scrollableParent, ScrollAxis.HORIZONTAL, scrollDiffX );\n    }\n\n    if( _scrollIntentions.vertical !== ScrollIntention.NONE ) {\n\n        scrollDiffY = Math.round( _options.velocityFn( _dynamicVelocity.y, _options.threshold ) * _scrollIntentions.vertical );\n        getSetElementScroll( _scrollableParent, ScrollAxis.VERTICAL, scrollDiffY );\n    }\n\n    if( isTopLevel ) {\n        // on top level element scrolling we need to translate the drag image as much as we scroll\n        _translateDragImageFn( scrollDiffX, scrollDiffY );\n    }\n    else {\n        // just scroll the container and update the drag image position without offset\n        _translateDragImageFn( 0, 0 );\n    }\n\n    // reset to make sure we can re-schedule scroll animation\n    _scrollAnimationFrameId = null;\n\n    // check if we should continue scrolling\n    //TODO implement scroll chaining? if scroll end is reached continue to look for scrollable parent\n    if( updateScrollIntentions( _currentCoordinates, _scrollableParent, _options.threshold, _scrollIntentions, _dynamicVelocity ) ) {\n\n        // re-schedule animation frame callback\n        scheduleScrollAnimation();\n    }\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"scroll checks\">\n\nfunction updateScrollIntentions( currentCoordinates:Point,\n                                 scrollableParent:HTMLElement,\n                                 threshold:number,\n                                 scrollIntentions:ScrollIntentions,\n                                 dynamicVelocity:Point ):boolean {\n\n    if( !currentCoordinates || !scrollableParent ) {\n\n        // when coordinates become undefined drag operation stopped. stop scrolling also.\n        return false;\n    }\n\n    const scrollableParentBounds:IScrollBounds = {\n        x: getElementViewportOffset( scrollableParent, ScrollAxis.HORIZONTAL ),\n        y: getElementViewportOffset( scrollableParent, ScrollAxis.VERTICAL ),\n        width: getElementViewportSize( scrollableParent, ScrollAxis.HORIZONTAL ),\n        height: getElementViewportSize( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollX: getSetElementScroll( scrollableParent, ScrollAxis.HORIZONTAL ),\n        scrollY: getSetElementScroll( scrollableParent, ScrollAxis.VERTICAL ),\n        scrollWidth: scrollableParent.scrollWidth,\n        scrollHeight: scrollableParent.scrollHeight\n    };\n\n    const currentCoordinatesOffset = {\n        x: currentCoordinates.x - scrollableParentBounds.x,\n        y: currentCoordinates.y - scrollableParentBounds.y\n    };\n\n    scrollIntentions.horizontal = determineScrollIntention( currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    scrollIntentions.vertical = determineScrollIntention( currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n\n    if( scrollIntentions.horizontal && isScrollEndReached( ScrollAxis.HORIZONTAL, scrollIntentions.horizontal, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.horizontal = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.horizontal ) {\n\n        dynamicVelocity.x = determineDynamicVelocity( scrollIntentions.horizontal, currentCoordinatesOffset.x, scrollableParentBounds.width, threshold );\n    }\n\n    if( scrollIntentions.vertical && isScrollEndReached( ScrollAxis.VERTICAL, scrollIntentions.vertical, scrollableParentBounds ) ) {\n\n        // if scroll end is reached, reset to none\n        scrollIntentions.vertical = ScrollIntention.NONE;\n    }\n    else if( scrollIntentions.vertical ) {\n\n        dynamicVelocity.y = determineDynamicVelocity( scrollIntentions.vertical, currentCoordinatesOffset.y, scrollableParentBounds.height, threshold );\n    }\n\n    return !!(scrollIntentions.horizontal || scrollIntentions.vertical);\n}\n\n//</editor-fold>\n\n//<editor-fold desc=\"public api\">\n\nexport interface ScrollOptions {\n    // threshold in px. when distance between scrollable element edge and touch position is smaller start programmatic scroll.\n    // defaults to 75px\n    threshold?:number;\n    // function to customize the scroll velocity\n    // velocity param: distance to scrollable element edge\n    // threshold: the threshold used to determine when scrolling should start\n    // defaults to cubic-ease-in.\n    velocityFn:( velocity:number, threshold:number ) => number;\n}\n\nexport const scrollBehaviourDragImageTranslateOverride:DragImageTranslateOverrideFn = handleDragImageTranslateOverride;\n\n//</editor-fold>\n"]},"metadata":{},"sourceType":"script"}